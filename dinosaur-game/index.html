<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML 恐龙跳跃</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* 隐藏滚动条 */
        }

        h1 {
            font-weight: 300;
            color: #555;
        }

        /* 游戏容器，用于定位UI元素 */
        #game-container {
            width: 600px;
            height: 200px;
            position: relative;
            border-bottom: 2px solid #666; /* 这是我们的“地面” */
            overflow: hidden; /* 确保仙人掌在容器外不可见 */
        }

        /* 画布将占据整个容器 */
        #gameCanvas {
            background-color: #f7f7f7;
            display: block;
        }

        /* 分数显示，定位在容器的右上角 */
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            font-family: 'Courier New', Courier, monospace;
            color: #555;
        }

        /* 游戏结束/开始消息，居中显示 */
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #333;
            font-size: 1.2em;
        }

        #message-overlay.hidden {
            display: none;
        }

        #message-overlay p {
            margin: 5px;
        }

    </style>
</head>
<body>

    <h1>恐龙跳跃</h1>
    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="200"></canvas>
        <div id="score">0</div>
        <div id="message-overlay">
            <p>按 [空格键] 开始游戏</p>
            <p id="game-over-text" class="hidden">游戏结束!</p>
        </div>
    </div>

    <script>
        // --- 1. 初始化和DOM获取 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const messageOverlay = document.getElementById('message-overlay');
        const gameOverText = document.getElementById('game-over-text');

        // 画布尺寸
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- 2. 游戏常量和物理 ---
        const GROUND_Y = HEIGHT - 20; // 地面Y坐标 (给恐龙留20px高)
        const GRAVITY = 0.8;
        const JUMP_FORCE = -15;
        const DINO_WIDTH = 30;
        const DINO_HEIGHT = 50;

        // --- 3. 游戏状态变量 ---
        let dino = {
            x: 50,
            y: GROUND_Y - DINO_HEIGHT,
            width: DINO_WIDTH,
            height: DINO_HEIGHT,
            dy: 0, // 垂直速度 (delta y)
            isJumping: false
        };

        let obstacles = [];         // 仙人掌数组
        let score = 0;
        let gameSpeed = 5;          // 初始游戏速度
        let baseGameSpeed = 5;
        let speedMultiplier = 0.001; // 速度随分数增加的乘数
        let frame = 0;              // 帧计数器
        let nextObstacleFrame = 100; // 下一个仙人掌出现的帧数
        let gameState = 'start';    // 游戏状态: 'start', 'playing', 'over'
        let animationFrameId = null; // 用于存储 requestAnimationFrame 的ID

        // --- 4. 绘图函数 ---

        function drawDino() {
            ctx.fillStyle = '#666'; // 灰色恐龙
            ctx.fillRect(dino.x, dino.y, dino.width, dino.height);
        }

        function drawObstacles() {
            ctx.fillStyle = '#107c10'; // 绿色仙人掌
            for (const obstacle of obstacles) {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
        }

        // --- 5. 游戏逻辑更新 ---

        function updateDino() {
            if (dino.isJumping) {
                dino.dy += GRAVITY;   // 施加重力
                dino.y += dino.dy;    // 更新Y位置

                // 检查是否落地
                if (dino.y + dino.height >= GROUND_Y) {
                    dino.y = GROUND_Y - dino.height; // 确保恐龙在地面上
                    dino.dy = 0;
                    dino.isJumping = false;
                }
            }
        }

        function updateObstacles() {
            // 从后向前遍历，这样删除时不会影响索引
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];
                obstacle.x -= gameSpeed; // 仙人掌向左移动

                // 如果仙人掌移出屏幕，则从数组中删除
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(i, 1);
                }

                // 碰撞检测
                if (checkCollision(dino, obstacle)) {
                    endGame();
                    return; // 游戏结束，停止更新
                }
            }
        }

        function spawnObstacle() {
            // 每隔一段时间生成仙人掌
            if (frame >= nextObstacleFrame) {
                // 随机仙人掌宽度 (模拟1个、2个或3个)
                const width = 20 + Math.random() * 40; 
                const height = 30 + Math.random() * 30; // 随机高度
                
                obstacles.push({
                    x: WIDTH, // 从屏幕右侧开始
                    y: GROUND_Y - height,
                    width: width,
                    height: height
                });

                // 设置下一个仙人掌出现的时间，随游戏速度加快而缩短间隔
                const minInterval = 50 / (gameSpeed / baseGameSpeed);
                const maxInterval = 150 / (gameSpeed / baseGameSpeed);
                nextObstacleFrame = frame + Math.floor(Math.random() * (maxInterval - minInterval + 1) + minInterval);
            }
        }

        function checkCollision(dino, obstacle) {
            // AABB 碰撞检测 (Axis-Aligned Bounding Box)
            // 简单版本：只要矩形有重叠
            return (
                dino.x < obstacle.x + obstacle.width &&
                dino.x + dino.width > obstacle.x &&
                dino.y < obstacle.y + obstacle.height &&
                dino.y + dino.height > obstacle.y
            );
        }

        function updateScore() {
            score++;
            scoreDisplay.textContent = String(score).padStart(5, '0'); // 5位数显示
            // 游戏速度随分数缓慢增加
            gameSpeed = baseGameSpeed + score * speedMultiplier;
        }

        // --- 6. 游戏主循环和状态管理 ---

        function gameLoop() {
            if (gameState !== 'playing') return; // 如果不是在玩，就停止循环

            clearCanvas();
            
            updateDino();
            spawnObstacle();
            updateObstacles();
            updateScore();
            
            drawDino();
            drawObstacles();

            frame++; // 推进帧数
            animationFrameId = requestAnimationFrame(gameLoop); // 请求下一帧
        }

        function startGame() {
            if (gameState === 'playing') return; // 防止重复开始

            // 重置所有变量
            gameState = 'playing';
            dino.y = GROUND_Y - DINO_HEIGHT;
            dino.dy = 0;
            dino.isJumping = false;
            obstacles = [];
            score = 0;
            frame = 0;
            gameSpeed = baseGameSpeed;
            nextObstacleFrame = 100;

            // 更新UI
            scoreDisplay.textContent = '00000';
            messageOverlay.classList.add('hidden');
            gameOverText.classList.add('hidden');

            // 取消可能存在的上一局动画帧，并开始新循环
            cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        function endGame() {
            gameState = 'over';
            // 停止动画循环
            cancelAnimationFrame(animationFrameId); 
            // 显示游戏结束信息
            messageOverlay.classList.remove('hidden');
            gameOverText.classList.remove('hidden');
        }

        function handleInput(e) {
            // 我们只关心空格键或向上箭头
            if (e.code !== 'Space' && e.code !== 'ArrowUp') {
                return;
            }

            e.preventDefault(); // 防止按空格键时页面滚动

            if (gameState === 'playing') {
                // 如果在玩，并且恐龙不在空中，则跳跃
                if (!dino.isJumping) {
                    dino.dy = JUMP_FORCE;
                    dino.isJumping = true;
                }
            } else {
                // 如果游戏处于 'start' 或 'over' 状态，则开始游戏
                startGame();
            }
        }

        // --- 7. 事件监听器和初始绘制 ---
        
        // 监听键盘按下事件
        document.addEventListener('keydown', handleInput);
        // 也可以添加点击/触摸支持
        document.addEventListener('touchstart', handleInput, { passive: false });
        document.addEventListener('mousedown', handleInput);


        // 游戏加载时，只绘制初始场景
        function initializeScene() {
            clearCanvas();
            drawDino();
        }
        
        initializeScene();

    </script>
</body>
</html>
